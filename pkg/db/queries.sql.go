// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.27.0
// source: queries.sql

package db

import (
	"context"
)

const getSlot = `-- name: GetSlot :one
SELECT id, name, description, "npHandle", "publishedIn", game, "firstPublished", "lastUpdated", "heartCount", background, icon, "rootLevel", missing_root_level FROM slot WHERE id = $1
`

func (q *Queries) GetSlot(ctx context.Context, id int64) (Slot, error) {
	row := q.db.QueryRow(ctx, getSlot, id)
	var i Slot
	err := row.Scan(
		&i.ID,
		&i.Name,
		&i.Description,
		&i.NpHandle,
		&i.PublishedIn,
		&i.Game,
		&i.FirstPublished,
		&i.LastUpdated,
		&i.HeartCount,
		&i.Background,
		&i.Icon,
		&i.RootLevel,
		&i.MissingRootLevel,
	)
	return i, err
}

const getSlotsSort = `-- name: GetSlotsSort :many
SELECT id, name, description, "npHandle", "publishedIn", game, "firstPublished", "lastUpdated", "heartCount", background, icon, "rootLevel", missing_root_level
FROM slot
WHERE (slot."npHandle" ILIKE $1) OR (slot.name ILIKE $1) OR (slot.description ILIKE $1)
order by (case when $2 = 'author' and $3 = 'ASC' then slot."npHandle" end) asc,
         (case when $2 = 'author' and $3 = 'DESC' then slot."npHandle" end) desc,
         (case when $2 = 'hearts' and $3 = 'ASC' then slot."heartCount" end) asc,
         (case when $2 = 'hearts' and $3 = 'DESC' then slot."heartCount" end) desc
OFFSET $4
    LIMIT 50
`

type GetSlotsSortParams struct {
	SearchQuery     string
	SearchColumn    interface{}
	SearchDirection interface{}
	SearchOffset    int32
}

func (q *Queries) GetSlotsSort(ctx context.Context, arg GetSlotsSortParams) ([]Slot, error) {
	rows, err := q.db.Query(ctx, getSlotsSort,
		arg.SearchQuery,
		arg.SearchColumn,
		arg.SearchDirection,
		arg.SearchOffset,
	)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []Slot
	for rows.Next() {
		var i Slot
		if err := rows.Scan(
			&i.ID,
			&i.Name,
			&i.Description,
			&i.NpHandle,
			&i.PublishedIn,
			&i.Game,
			&i.FirstPublished,
			&i.LastUpdated,
			&i.HeartCount,
			&i.Background,
			&i.Icon,
			&i.RootLevel,
			&i.MissingRootLevel,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getSlotsSortAuthor = `-- name: GetSlotsSortAuthor :many
SELECT id, name, description, "npHandle", "publishedIn", game, "firstPublished", "lastUpdated", "heartCount", background, icon, "rootLevel", missing_root_level
FROM slot
WHERE (slot."npHandle" ILIKE $1) OR (slot.name ILIKE $1) OR (slot.description ILIKE $1)
order by slot."npHandle"
OFFSET $2
    LIMIT 50
`

type GetSlotsSortAuthorParams struct {
	SearchQuery  string
	SearchOffset int32
}

func (q *Queries) GetSlotsSortAuthor(ctx context.Context, arg GetSlotsSortAuthorParams) ([]Slot, error) {
	rows, err := q.db.Query(ctx, getSlotsSortAuthor, arg.SearchQuery, arg.SearchOffset)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []Slot
	for rows.Next() {
		var i Slot
		if err := rows.Scan(
			&i.ID,
			&i.Name,
			&i.Description,
			&i.NpHandle,
			&i.PublishedIn,
			&i.Game,
			&i.FirstPublished,
			&i.LastUpdated,
			&i.HeartCount,
			&i.Background,
			&i.Icon,
			&i.RootLevel,
			&i.MissingRootLevel,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getSlotsSortAuthorDesc = `-- name: GetSlotsSortAuthorDesc :many
SELECT id, name, description, "npHandle", "publishedIn", game, "firstPublished", "lastUpdated", "heartCount", background, icon, "rootLevel", missing_root_level
FROM slot
WHERE (slot."npHandle" ILIKE $1) OR (slot.name ILIKE $1) OR (slot.description ILIKE $1)
order by slot."npHandle" desc
OFFSET $2
    LIMIT 50
`

type GetSlotsSortAuthorDescParams struct {
	SearchQuery  string
	SearchOffset int32
}

func (q *Queries) GetSlotsSortAuthorDesc(ctx context.Context, arg GetSlotsSortAuthorDescParams) ([]Slot, error) {
	rows, err := q.db.Query(ctx, getSlotsSortAuthorDesc, arg.SearchQuery, arg.SearchOffset)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []Slot
	for rows.Next() {
		var i Slot
		if err := rows.Scan(
			&i.ID,
			&i.Name,
			&i.Description,
			&i.NpHandle,
			&i.PublishedIn,
			&i.Game,
			&i.FirstPublished,
			&i.LastUpdated,
			&i.HeartCount,
			&i.Background,
			&i.Icon,
			&i.RootLevel,
			&i.MissingRootLevel,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getSlotsSortFirstPublished = `-- name: GetSlotsSortFirstPublished :many
SELECT id, name, description, "npHandle", "publishedIn", game, "firstPublished", "lastUpdated", "heartCount", background, icon, "rootLevel", missing_root_level
FROM slot
WHERE (slot."npHandle" ILIKE $1) OR (slot.name ILIKE $1) OR (slot.description ILIKE $1)
order by slot."firstPublished"
OFFSET $2
    LIMIT 50
`

type GetSlotsSortFirstPublishedParams struct {
	SearchQuery  string
	SearchOffset int32
}

func (q *Queries) GetSlotsSortFirstPublished(ctx context.Context, arg GetSlotsSortFirstPublishedParams) ([]Slot, error) {
	rows, err := q.db.Query(ctx, getSlotsSortFirstPublished, arg.SearchQuery, arg.SearchOffset)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []Slot
	for rows.Next() {
		var i Slot
		if err := rows.Scan(
			&i.ID,
			&i.Name,
			&i.Description,
			&i.NpHandle,
			&i.PublishedIn,
			&i.Game,
			&i.FirstPublished,
			&i.LastUpdated,
			&i.HeartCount,
			&i.Background,
			&i.Icon,
			&i.RootLevel,
			&i.MissingRootLevel,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getSlotsSortFirstPublishedDesc = `-- name: GetSlotsSortFirstPublishedDesc :many
SELECT id, name, description, "npHandle", "publishedIn", game, "firstPublished", "lastUpdated", "heartCount", background, icon, "rootLevel", missing_root_level
FROM slot
WHERE (slot."npHandle" ILIKE $1) OR (slot.name ILIKE $1) OR (slot.description ILIKE $1)
order by slot."firstPublished" desc
OFFSET $2
    LIMIT 50
`

type GetSlotsSortFirstPublishedDescParams struct {
	SearchQuery  string
	SearchOffset int32
}

func (q *Queries) GetSlotsSortFirstPublishedDesc(ctx context.Context, arg GetSlotsSortFirstPublishedDescParams) ([]Slot, error) {
	rows, err := q.db.Query(ctx, getSlotsSortFirstPublishedDesc, arg.SearchQuery, arg.SearchOffset)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []Slot
	for rows.Next() {
		var i Slot
		if err := rows.Scan(
			&i.ID,
			&i.Name,
			&i.Description,
			&i.NpHandle,
			&i.PublishedIn,
			&i.Game,
			&i.FirstPublished,
			&i.LastUpdated,
			&i.HeartCount,
			&i.Background,
			&i.Icon,
			&i.RootLevel,
			&i.MissingRootLevel,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getSlotsSortHearts = `-- name: GetSlotsSortHearts :many
SELECT id, name, description, "npHandle", "publishedIn", game, "firstPublished", "lastUpdated", "heartCount", background, icon, "rootLevel", missing_root_level
FROM slot
WHERE (slot."npHandle" ILIKE $1) OR (slot.name ILIKE $1) OR (slot.description ILIKE $1)
order by slot."heartCount"
OFFSET $2
    LIMIT 50
`

type GetSlotsSortHeartsParams struct {
	SearchQuery  string
	SearchOffset int32
}

func (q *Queries) GetSlotsSortHearts(ctx context.Context, arg GetSlotsSortHeartsParams) ([]Slot, error) {
	rows, err := q.db.Query(ctx, getSlotsSortHearts, arg.SearchQuery, arg.SearchOffset)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []Slot
	for rows.Next() {
		var i Slot
		if err := rows.Scan(
			&i.ID,
			&i.Name,
			&i.Description,
			&i.NpHandle,
			&i.PublishedIn,
			&i.Game,
			&i.FirstPublished,
			&i.LastUpdated,
			&i.HeartCount,
			&i.Background,
			&i.Icon,
			&i.RootLevel,
			&i.MissingRootLevel,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getSlotsSortHeartsDesc = `-- name: GetSlotsSortHeartsDesc :many
SELECT id, name, description, "npHandle", "publishedIn", game, "firstPublished", "lastUpdated", "heartCount", background, icon, "rootLevel", missing_root_level
FROM slot
WHERE (slot."npHandle" ILIKE $1) OR (slot.name ILIKE $1) OR (slot.description ILIKE $1)
order by slot."heartCount" desc
OFFSET $2
    LIMIT 50
`

type GetSlotsSortHeartsDescParams struct {
	SearchQuery  string
	SearchOffset int32
}

func (q *Queries) GetSlotsSortHeartsDesc(ctx context.Context, arg GetSlotsSortHeartsDescParams) ([]Slot, error) {
	rows, err := q.db.Query(ctx, getSlotsSortHeartsDesc, arg.SearchQuery, arg.SearchOffset)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []Slot
	for rows.Next() {
		var i Slot
		if err := rows.Scan(
			&i.ID,
			&i.Name,
			&i.Description,
			&i.NpHandle,
			&i.PublishedIn,
			&i.Game,
			&i.FirstPublished,
			&i.LastUpdated,
			&i.HeartCount,
			&i.Background,
			&i.Icon,
			&i.RootLevel,
			&i.MissingRootLevel,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getSlotsSortLastUpdated = `-- name: GetSlotsSortLastUpdated :many
SELECT id, name, description, "npHandle", "publishedIn", game, "firstPublished", "lastUpdated", "heartCount", background, icon, "rootLevel", missing_root_level
FROM slot
WHERE (slot."npHandle" ILIKE $1) OR (slot.name ILIKE $1) OR (slot.description ILIKE $1)
order by slot."lastUpdated"
OFFSET $2
    LIMIT 50
`

type GetSlotsSortLastUpdatedParams struct {
	SearchQuery  string
	SearchOffset int32
}

func (q *Queries) GetSlotsSortLastUpdated(ctx context.Context, arg GetSlotsSortLastUpdatedParams) ([]Slot, error) {
	rows, err := q.db.Query(ctx, getSlotsSortLastUpdated, arg.SearchQuery, arg.SearchOffset)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []Slot
	for rows.Next() {
		var i Slot
		if err := rows.Scan(
			&i.ID,
			&i.Name,
			&i.Description,
			&i.NpHandle,
			&i.PublishedIn,
			&i.Game,
			&i.FirstPublished,
			&i.LastUpdated,
			&i.HeartCount,
			&i.Background,
			&i.Icon,
			&i.RootLevel,
			&i.MissingRootLevel,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getSlotsSortLastUpdatedDesc = `-- name: GetSlotsSortLastUpdatedDesc :many
SELECT id, name, description, "npHandle", "publishedIn", game, "firstPublished", "lastUpdated", "heartCount", background, icon, "rootLevel", missing_root_level
FROM slot
WHERE (slot."npHandle" ILIKE $1) OR (slot.name ILIKE $1) OR (slot.description ILIKE $1)
order by slot."lastUpdated" desc
OFFSET $2
    LIMIT 50
`

type GetSlotsSortLastUpdatedDescParams struct {
	SearchQuery  string
	SearchOffset int32
}

func (q *Queries) GetSlotsSortLastUpdatedDesc(ctx context.Context, arg GetSlotsSortLastUpdatedDescParams) ([]Slot, error) {
	rows, err := q.db.Query(ctx, getSlotsSortLastUpdatedDesc, arg.SearchQuery, arg.SearchOffset)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []Slot
	for rows.Next() {
		var i Slot
		if err := rows.Scan(
			&i.ID,
			&i.Name,
			&i.Description,
			&i.NpHandle,
			&i.PublishedIn,
			&i.Game,
			&i.FirstPublished,
			&i.LastUpdated,
			&i.HeartCount,
			&i.Background,
			&i.Icon,
			&i.RootLevel,
			&i.MissingRootLevel,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getSlotsSortName = `-- name: GetSlotsSortName :many
SELECT id, name, description, "npHandle", "publishedIn", game, "firstPublished", "lastUpdated", "heartCount", background, icon, "rootLevel", missing_root_level
FROM slot
WHERE (slot."npHandle" ILIKE $1) OR (slot.name ILIKE $1) OR (slot.description ILIKE $1)
order by slot.name
OFFSET $2
LIMIT 50
`

type GetSlotsSortNameParams struct {
	SearchQuery  string
	SearchOffset int32
}

func (q *Queries) GetSlotsSortName(ctx context.Context, arg GetSlotsSortNameParams) ([]Slot, error) {
	rows, err := q.db.Query(ctx, getSlotsSortName, arg.SearchQuery, arg.SearchOffset)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []Slot
	for rows.Next() {
		var i Slot
		if err := rows.Scan(
			&i.ID,
			&i.Name,
			&i.Description,
			&i.NpHandle,
			&i.PublishedIn,
			&i.Game,
			&i.FirstPublished,
			&i.LastUpdated,
			&i.HeartCount,
			&i.Background,
			&i.Icon,
			&i.RootLevel,
			&i.MissingRootLevel,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getSlotsSortNameDesc = `-- name: GetSlotsSortNameDesc :many
SELECT id, name, description, "npHandle", "publishedIn", game, "firstPublished", "lastUpdated", "heartCount", background, icon, "rootLevel", missing_root_level
FROM slot
WHERE (slot."npHandle" ILIKE $1) OR (slot.name ILIKE $1) OR (slot.description ILIKE $1)
order by slot.name desc
OFFSET $2
    LIMIT 50
`

type GetSlotsSortNameDescParams struct {
	SearchQuery  string
	SearchOffset int32
}

func (q *Queries) GetSlotsSortNameDesc(ctx context.Context, arg GetSlotsSortNameDescParams) ([]Slot, error) {
	rows, err := q.db.Query(ctx, getSlotsSortNameDesc, arg.SearchQuery, arg.SearchOffset)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []Slot
	for rows.Next() {
		var i Slot
		if err := rows.Scan(
			&i.ID,
			&i.Name,
			&i.Description,
			&i.NpHandle,
			&i.PublishedIn,
			&i.Game,
			&i.FirstPublished,
			&i.LastUpdated,
			&i.HeartCount,
			&i.Background,
			&i.Icon,
			&i.RootLevel,
			&i.MissingRootLevel,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}
